using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Text;

namespace generators
{
    // NOT WORK
    [Generator]
    public class AdapterSourceGenerators : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context) { }

        public void Execute(GeneratorExecutionContext context)
        {
            context.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor("GEN001", "Generator", "Generator is running", "Usage", DiagnosticSeverity.Info, true), Location.None));
            
            var syntaxTrees = context.Compilation.SyntaxTrees;

            foreach (var tree in syntaxTrees)
            {
                var root = tree.GetRoot();
                //var semanticModel = context.Compilation.GetSemanticModel(tree);
                var interfaceDeclarations = root.DescendantNodes().OfType<InterfaceDeclarationSyntax>()
                    .Where(i => i.Identifier.Text == "IMovable");

                foreach (var interfaceDeclaration in interfaceDeclarations)
                {
                    var className = interfaceDeclaration.Identifier.Text + "Adapter";
                    var source = GenerateAdapterClass(className, interfaceDeclaration);
                    context.AddSource($"{className}.g.cs", source);
                }
            }
        }

        private string GenerateAdapterClass(string className, InterfaceDeclarationSyntax interfaceDeclaration)
        {
            var interfaceName = interfaceDeclaration.Identifier.Text;

            var sb = new StringBuilder();
            sb.AppendLine($"// <auto-generated/>");
            sb.AppendLine($"using System.Numerics;");
            sb.AppendLine($"using factory;");
            sb.AppendLine($"using commands;");
            sb.AppendLine($"using SpaceBattle.Interfaces;");

            sb.AppendLine($"namespace Generators");
            sb.AppendLine("{");

            sb.AppendLine($"    public class {className} : {interfaceName}");
            sb.AppendLine("    {");

            sb.AppendLine($"        private object _obj;");
            sb.AppendLine($"        public {className}(object obj)");
            sb.AppendLine("        {");
            sb.AppendLine("            _obj = obj;");
            sb.AppendLine("        }");

            foreach (var member in interfaceDeclaration.Members)
            {
                if (member is MethodDeclarationSyntax method)
                {
                    var returnType = method.ReturnType.ToString();
                    var methodName = method.Identifier.Text;
                    var parametersWithType = string.Join(", ", method.ParameterList.Parameters.Select(p => $"{p.Type} {p.Identifier.Text}"));
                    var parametersWithoutType = string.Join(", ", method.ParameterList.Parameters.Select(p => $"{p.Identifier.Text}"));

                    if (methodName.ToUpper().StartsWith("SET"))
                    {
                        sb.AppendLine($"        public {returnType} {methodName}({parametersWithType})");
                        sb.AppendLine("        {");
                        sb.AppendLine($"            return IoC.Resolve<ICommand>(\"{interfaceName}:{methodName}\", _obj, {parametersWithoutType}).Execute();");
                        sb.AppendLine("        }");
                    } else {
                        sb.AppendLine($"        public {returnType} {methodName}({parametersWithType})");
                        sb.AppendLine("        {");
                        sb.AppendLine($"            return IoC.Resolve<{returnType}>(\"{interfaceName}:{methodName}\", _obj);");
                        sb.AppendLine("        }");
                    }
                }
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

    }
}
